## 멀티스레드 동시성 제어

- Synchronized를 이용한 동시접근제어

  멀티스레드 프로그램에서는 하나의 데이터를 동시에 여러 스레드가 접근해서 수정할 수 있다. 이때 동시성제어가 일어나지 않으면 원하지 않는 결과가 일어날 수 있다

  synchronized를 사용하는 것은 클래스를 **lock** 해놓고, **key**를 가지고 있는 Thread부터 순차적으로 사용한다는 것을 의미한다. 물론 key는 1개 뿐이다.

  컴퓨터 용어로 상호배제 Mutex(Mutual Exclusion)이라고도 한다

  이렇게 동기화된 클래스를 우리는 스레드에 대해 안전하다고 하며, Thread safe하다고 한다

  결국, 순서대로 쓰도록 만들어 둔 클래스라는 의미인데, 동시에 사용할 수 없게 순차적으로 사용하도록 만들어 둔 것에 지나지 않다. 그래서 synchronized가 사용된 클래스를 동시에 사용하게 되면, 순차적으로 밖에 사용할 수 없으므로 **성능저하**가 일어나게 된다.

  

- synchronized - 블록사용

  synchronized 지정자는 메소드 앞에서 쓰이는 것 외에 별도 블록을 지정하여 사용할 수도 있다. 블록을 지정할 때에 공유를 잠그어 둘 대상 클래스를 명시하여야 한다.

  ex) synchronized(인스턴스){

  ​	인터스에 대한 키를 얻으면 순차적으로 실행할 코드 기술

  }

  단, 키를 갖는 인스턴스는 스레드가 생성될 때마다 별도의 키가 만들어지게 하면 안된다.

  스레드끼리 키를 **공유**해야 하는데, 각각 개별 키를 갖게 되면 lock을 걸어둔 의미가 퇴색해진다

  

- wati(), notifyAll() 를 통한 스레드 순서 제어

  클래스의 멤버변수가 어떤 조건이 될 때까지 기다렸다가 실행되도록 할 수는 없다.

  즉, 한 메소드를 실행할 때, 어떤 조건이 되지 않으면 기다리고, 조건이 되면 다시 깨어나서 실행하도록 하고 싶을 때가 있다.

  조건을 만족시키게 하는 메소드에서는 조건을 만족시키는 일을 하고 나서 다른 스레드를 깨워서 조건이 만족되었다고 알려주어야 한다.

  공통으로 사용하면 공용클래스에 2개의 메소드가 필요하다.

  - 메소드 1: 조건이 만족될 떄까지 스레드 실행을 중단하고 기다린다(wait());
  - 메소드 2: 조건을 만족시키고 나서 다른 스레드를 깨워서 다시 실행하라고 알린다.(notifyAll()); 

  주의할점 : wait(), nofihyAll() 메소드 모두 synchronized되어 있는 구문 내에서만 호출되어야 한다. 잠을 자거나 깨울 때, 순서대로 처리하는 synchronized 구문 내에서 처리하지 않으면, 여러 개의 스레드가 실행되는 환경에서 잠자고 깨는 조건을 여러 스레드가 동시에 접근해서 수정하거나 조회하게 되므로, 정상적은 프로그램이 되지 않기 때문에 java에서 synchronized 구문 내에서만 처리하도록 안전장치를 걸어 놓았다라고 생각하면 된다.

  참고 : notifyAll() 메소드가 아닌 notify() 메소드가 있는데, 이 메소드는 여러 개 잠자고 있던 스레드 중에 1개만 깨워서 일을 하게 한다.
  번거롭게 모든 스레드를 다 깨우지 않고, 하나만 꺠워서 일하는게 나을 때 사용하면 좋다.

