# [DB] 인덱스(Index)

## Index의 필요성

DB Index의 필요성을 위해 Full Table Scan을 알아보겠습니다.

### Full Table Scan(순차 접근)

- Full Table Scan이란 데이터베이스의 한 릴레이션에서 데이터를 찾거나 재배열하기 위해 **데이터가 저장된 목록 중 모든 데이터 요소를 순차적으로 조사하여 원하는 것을 찾아내는 것**을 말합니다.
- 이런 순차 접근에 의한 검색은 **Tuple의 수가 많아질수록 검색 시간이 매우 오래걸립니다.**

DB는 Index가 설정되어 있지 않으면 Full Table Scan 방식으로 데이터를 찾음으로써 속도가 매우 느려지게 됩니다. 이 문제를 해결하기 위해 DB에서 Index 기능을 제공합니다.

</br >

## Index란?

Index는 RDBMS에서 검색도를 높이기 위해 사용하는 기술입니다.

특정 Table의 컬럼을 색인화(파일로 저장) 하여 검색시 해당 **Table의 레코드를 Full Table Sacn 하는게 아니라 색인화 되어있는 Index파일을 검색하여 검색속도를 빠르게 합니다.**

해당 테이블의 칼럼의 값과 해당 레코드가 저장된 주소를 Key-Value 쌍으로 Index를 만들어 두고, 이렇게 **지정한 칼럼의 값을 주어진 순서로 미리 정렬해서 보관**합니다.

그렇기 때문에 데이터가 저장될 때마다 값을 항상 정렬해야 하므로 저장 과정이 복잡하고 느리지만, 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있습니다.

즉, **Index는 INSERT, UPDATE, DELETE 성능을 희생하고, SELECT 성능을 향상시키는 기능입니다.** 그렇기 때문에 테이블에 Index를 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 결정돼야 합니다. 

</br >

### INSERT

- index split 현상이 발생할 수 있습니다.
  - Index split: 인덱스의 페이지들이 하나에서 두 개로 나누어지는 현상
- 기존 페이지에 여유 공간이 없는 상황에서 그 페이지에 새로운 데이터가 입력되는 경우 발생합니다
- 이렇게되면 기존 페이지의 내용 중 일부를 새 페이지에다가 기록한 후 기존 페이지에 빈 공간을 만들어 새로운 데이터를 추가하게 됩니다.
- 즉, **새로운 페이지를 할당 받고 key를 옮기는 복잡한 작업을 수행합니다.**

</br >

### DELETE

- 테이블에서 데이터가 delete될 경우: 데이터가 지워지고, 다른 데이터가 그 공간을 사용 가능합니다.
- index에서 데이터가 delete될 경우:  **데이터가 지워지지 않고, 사용 안 됨 표시만 해둡니다.**
- 즉, 테이블에서 데이터가 1만건이 있는 경우, 인덱스에는 2만건의 데이터가 있을 수 있습니다.

</br >

### UPDATE

- 테이블에 update가 발생할 경우 **인덱스에서는 delete가 먼저 발생한 후 새로운 작업의 insert가 발생합니다.**
- 즉, **delete와 insert 두 개의 작업이 인덱스에 동시에 일어나 더 큰 부하를 주게 됩니다.**

</br >

## B-Tree 인덱스

B-Tree 인덱스는 DB의 인덱싱 알고리즘중 가장 일반적으로 사용되는 알고리즘 입니다. 여기서 B는 Binary가 아니고, Balanced를 의미합니다.

### B-Tree 인덱스 구조

B-Tree는 최상위에 하나의 루트 노드와 하위의 자식 노드가 붙어 있는 형태입니다.

탐색 순서는 Root -> Branch -> Leaf 순으로 진행되며, 실제 데이터 레코드를 찾아가기 위한 주소 값은 는 Leaf Node가 알고있습니다.

![img](https://blog.kakaocdn.net/dn/bmpdWB/btqZfig7mOu/NA8NhW4Y1uZep6CdsZxnM1/img.png)

</br >

# B-Tree 인덱스 사용에 영향을 미치는 요소

## 1. 인덱스 키값의 크기

인덱스는 페이지 단위로 관리됩니다. 위 B-Tree 그림에서 각각의 노드를 구분한 기준이 바로 페이지 단위입니다.  B-Tree의 자식 노드의 개수는 가변적인 구조로, **페이지의 크기와 키 값의 크기에 따라 결정**됩니다.

InnoDB의 모든 페이지 크기는 16KB로 고정돼 있습니다. 만약 인덱스의 키가 16byte라고 가정하고 자식 노드 주소가 12byte로 구성된다고 가정해 보겠습니다. 이 경우 하나의 인덱스 페이지에 몇 개의 키를 저장할 수 있을까요?

`16*1024/(16+12) = 585`개 저장할 수 있습니다. 만약 여기서 인덱스 키 값이 32byte로 늘어났다고 가정하면 한 페이지에 인덱스 키를 `16*1024(16+12) = 372`개 저장할 수 있습니다.

만약 SELECT 쿼리가 레코드를 500개 이상 읽어야 한다면 전자는 한 번, 후자는 두 번 이상 디스크로부터 읽어야 하기 때문에, 그만큼 느려진다는 것을 의미합니다.

결론적으로 키 값이 커질수록 해당 페이지에 저장할 수 있는 인덱스 개수가 적어지기 때문에, 인덱스 크기가 커질수록 성능 저하가 일어날 수 있습니다.

</br >

## 2. 인덱스 컬럼 기준

만약 1개의 컬럼만 인덱스를 걸어야 한다면, 해당 컬럼은 **중복 수치가 가장 낮은 것**으로 잡아야 합니다. 또한, 다중 컬럼으로 인덱스를 잡는다면 **중복 수치가 낮은 -> 높은** 순으로 구성하는게 좋습니다.

- ex) 중복 수치가 높은 것: 성별, 학년
- ex) 중복 수치가 낮은 것: 주민등록번호, 계좌번호

중복 수치가 낮은 것으로 잡는 이유는 인덱스로 최대한 효율을 뽑아내려면, **해당 인덱스로 많은 부분을 걸러내야 하기 때문입니다.**

예를 들어 10,000개의 데이터가 있다고 가정해 보겠습니다. 이중 인덱스로 설정한 칼럼의 유니크 값이 10개일 때, 해당 인덱스로 값을 검색하면 1000건(10,000/10)이 일치할 것을 예상할 수 있습니다.

만약, 인덱스로 설정한 칼럼의 유니크 값이 1,000개일 때, 해당 인덱스로 값을 검색하면 10건(10,000/1,000)이 일치할 것을 예상할 수 있습니다.

이처럼 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미치게 됩니다.

</br >

## 3. 비교 조건의 종류와 효율성

두개 이상의 칼럼을 인덱스로 지정할 때 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등("=")인지 크다(">") 또는 작다("<")와 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

~~~sql
SELECT *
FROM dept_emp
WHERE dept_no = 'd002' AND emp_no >= 10144;
~~~

위 쿼리를 위해 dept_emp 테이블에 각각 칼럼의 순서만 다른 2가지 케이스로 인덱스를 생성했다고 가정하자.

![image-20211109223747285](/Users/bang/Library/Application Support/typora-user-images/image-20211109223747285.png)

### 첫 번째 케이스 (dept_no + emp_no)

- 이 케이스는 `dept_no = 'd002' AND emp_no >= 10144`인 레코드를 찾고, 그 이후에 dept_no가 'd002'가 아닐 때까지 인덱스를 쭉 읽는다.
- 이 경우에는 인덱스에서 2번째 칼럼(emp_no)는 **비교 작업의 범위를 좁히는데 도움을 준다.**

</br >

### 두 번째 케이스 (emp+no + dept_no)

- 이 케이스는 `emp_no >= 10114 AND dept_no = 'd002'`인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교하는 과정을 거친다.
- 이 경우에는 인덱스에서 2번째 칼럼(dept_no)는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 못하고, **단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용된다.**

>작업 범위 결정 조건
>
>- 첫 번째 케이스에서 dept_no = 'd002' 와 emp_no >= 10144 와 같이 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라 한다.
>
>필터링 조건 (체크 조건)
>
>- 두 번째 케이스에서 dept_no = 'd002' 조건과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 '필터링 조건' 또는 '체크 조건'이라고 한다.
>
>작업 범위 결정 조건이 많은수록 쿼리의 처리 성능을 높이지만 필터링 조건은 많다고 해서 쿼리의 처리 성능을 높이지는 못한다.

</br >

## 4. 인덱스의 가용성

B-Tree 인덱스의 특징은 왼쪽 값(Left-most)에 기준해서 오른쪽 값이 정렬돼 있다. 이는 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용된다.

다음 두 가지 케이스가 있다.

- A 케이스: INDEX(first_name)
- B 케이스: INDEX(dept_no, emp_no)

~~~sql
SELECT * FROM employees WHERE first_name LIKE '%mer';
~~~

위 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다. 이유는 다음과 같다.

- `first_name` 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 한다.
- 하지만 조건절(WHERE)을 보면 상수값('%mer')에는 왼쪽 부분이 고정되지 않는다.
- **따라서 정렬 우선순위가 낮은 뒷부분의 값만으로는 왼족 기준(Left-most) 정렬 기반의 인덱스인 B-Tree에서는 인덱스의 효과를 얻을 수 없다.**

</br >

## 5. B-Tree 인덱스에서 사용할 수 없는 조건

### 1. NOT-EQUAL로 비교된 경우("<>", 'NOT BETWEEN", "IS NOT NULL")

- WHERE column <> 'N'
- WHERE column NOT IN (10, 11, 12)
- WHERE column IS NOT NULL

</br >

### 2. LIKE '%??' (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우

- WHERE column LIKE '%승환'
- WHERE column LIKE '_승환'
- WHERE column LIKE '%승%'

</br >

### 3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우

- WHERE SUBSTRING(column, 1, 1) = 'X'
- WHERE DAYOFMONTH(column) = 1

</br >

### 4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

- WHERE column = deterministic_function()

</br >

### 5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)

- WHERE char_column = 10

</br >

### 6. 문자열 데이터 타입의 콜레이션이 다른 경우

- WHERE utf8_bin_char_column = euckr_bin_char_column

</br >

## 6. 다중 컬럼으로 만들어진 인덱스 조건

~~~sql
INDEX ix_test (column_1, column_2, ... , column_n)
~~~

### 1. 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우

- column_1 칼럼에 대한 조건이 없는 경우
- column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건(5. B-Tree 인덱스에서 사용할 수 없는 조건) 중 하나인 경우

</br >

### 2. 작업 범위 결정 조건으로 인덱스를 사용하는 경우 (i는 2보다 크고 n보다 작은 임의 값)

1. column_1 ~ column_(i-1) 칼럼까지 Equal 형태("=" 또는 "IN")로 비교
2. column_i 칼럼에 대해 다음 연산자 중 하나로 비교
   - Equal ("=" 또는 "IN")
   - 크다 작다 형태(">", "<")
   - LIKE로 좌측 일치 패턴 (LIKE '승환%')

위 2가지 조건을 모두 만족하는 쿼리는 column_1부터 column_i까지는 범위 결정 조건으로, column_i부터 column_n까지의 조건은 체크 조건으로 사용된다.

</br >

### 다양한 쿼리 예제

- 인덱스를 사용할 수 없는 쿼리
  - WHERE column_1 <> 2
- column_1과 column_2까지 범위 결정 조건으로 사용
  - WHERE column_1 = 1 AND column_2 > 10
- column_1, column_2, column_3까지 범위 결정 조건으로 사용
  - WHERE column_1 IN (1,2) AND column_2 = 2 AND column_3 <= 10
- column_1, column_2, column_3까지 범위 결정 조건으로, column_4는 체크 조건으로 사용
  - WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10, 20, 30 AND column_4 <> 100

