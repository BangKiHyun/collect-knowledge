# [DB] MySQL 잠금(Lock)

## 글로벌 락(Global Lock)

글로벌 락은 **FLUSH TABLES WITH READ LOCK** 명령어로 획득할 수 있다.

### 특징

- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
  - 글로벌 락 실행과 동시에 MySQL 서버에 존재하는 모든 테이블의 잠금을 건다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT을 제외한 대부분의 DDL, DML 문장을 실행할 경우 글로벌 락이 해제될 떄까지 해당 문장이 대기 상태로 남는다.
- FLUSH TABLES WITH READ LOCK 명령을 실행하기 위해 먼저 테이블을 플러시 해야 한다.
  - 즉, 테이블에 실행되고 있는 모든 종류의 쿼리가 완료돼야만 테이블을 플러시하고 잠글 수 있다.

</br >

## 테이블 락(Table Lock)

개별 테이블 단위로 설정되는 잠금으로, 묵시적 또는 명시적으로 특정 테이블의 락을 획들할 수 있다.

### 명시적 테이블 락

- 명령어: **LOCK TABLES table [READ | WRITE]**
- 명시적으로 획득한 잠금 해제 방법: **UNLOCK TABLES**

</br >

### 묵시적 테이블 락

- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
- 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제한다.
  - 즉, 쿼리가 실행되는 동안 자동적으로 획득했다가 쿼리가 완료된 후 자동 해제된다.

</br >

## 유저 락(User Lock)

유저 락은 **GET_LOCK()** 함수를 이용해 임의로 잠금을 설정할 수 있다.

### 특징

- 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니다.
- 단순히 사용자가 지정한 문자(String)에 대해 획득하고 반납(해제)하는 잠금이다.

</br >

### 유저 락을 사용하면 좋을 때

- 클라이언트가 상호 동기화를 처리해야할 때
  - 한 대의 데이터베이스에 여러대의 웹 서버가 접속해서 서비스를 하고 있는 상황에서 여러대의 웹 서버가 어던 정보를 동기화해야하는 요건
- 많은 레코드를 한 번에 변경하는 트랜잭션의 경우
  - 한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인 될 수 있다.
  - 이때 동일한 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.

</br >

## 네임 락(Name Lock)

데이터베이스 객체(테이블이나 뷰 등)의 이름을 변경하는 경우 획득하는 잠금이다.

- 네임 락은 명시적으로 획득하는게 아닌 **RENAME TABLE tab_a TO tab_b** 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
  - **RENAME TABLE** 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.

</br >

### 예제

- 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성한다.
- 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank) 을 rank_backup으로 백업한다.
- 새로 만들어진 랭킹 테이블(rank_new)을 서비스용으로 대체한다.

명령어: **RENAME TABLE rank To rank_backup, rank_new To rank**

