# DB 인덱스 스캔

## 스캔이란?

1. 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가 원하는 시작 지점을 찾는다.
2. 시작 지점을 찾은 다음부터는 리프 노드의 레코드를 순서대로 읽으면 된다.

이렇게 차례대로 쭉 읽는 것을 스캔이라고 한다.

</br >

## 인덱스 레인지 스캔(Range)

인덱스의 접근 방법 가운데 가장 대표적인 접근 방식이다.

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레이지 스캔이라 표현한다.

B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 특정 검색(스캔) 시작 값을 가지고 있는 리프 노드를 검색하고, 그 지점부터 필요한 방향(오름차순 or 내림차순)으로 인덱스를 읽어 나간다.

이때 중요한 점으로는 어떤 방식으로 스캔하든 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다는 것이다. (인덱스 자체의 정렬 특성 때문)

![image](https://user-images.githubusercontent.com/43977617/140933359-db094058-13b2-4cf0-8b7c-e28aabcbc698.png)

</br >

## 인덱스 풀 스캔(Full)

인덱스 풀 스캔은 인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는다.

- 대표적으로 **쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.**
  - 예로 인덱스가 (A, B, C) 칼럼의 순서대로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우다.
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.
- 인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않는다.

</br >

### 스캔 순서

1. 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한다.
2. 인덱스의 리프 노드를 연결하는 링크드 리스트(Linked list)를 따라서 처음부터 끝까지 스캔한다.

인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. 다만 인덱스 풀 스캔 방식은 효율적인 방식은 아니며, 일반적으로 인덱스를 생성하는 목적이 아니기 때문이다.

![image](https://user-images.githubusercontent.com/43977617/140933456-93e0e31b-1f4a-4b70-bd43-33bdb9a2be1b.png)

</br >

## 루스 인덱스 스캔(Loose)

루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 동작하지만, 중간마다 필요치 않은 인덱스 키값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.

일반적으로 **GROUP BY** 또는 집합 함수 가운데 **MAX(), MIN()** 함수에 대해 최적화를 하는 경우 사용된다.

~~~sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002', AND 'd004'
GROUP BY dept_no;
~~~

- 위 예제에서 dept_emp 테이블은 dept_no와 emp_no 두 개의 칼럼으로 인덱스가 생성돼 있다고 가정하자.
- 또한 이 인덱스는 dept_no + emp_no의 값으로 정렬되어 있다면, dept_no 그룹별로 제일 첫 번째 emp_no 값만 읽으면 된다.
- 즉, 인덱스에서 WHRER 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 걸 옵티마이저가 알고 있기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동한다.

![image](https://user-images.githubusercontent.com/43977617/140933532-f1a35a99-75fa-45ae-86ae-2dac9ecc68ca.png)

</br >

## 다중 칼럼 인덱스(Multi-column)

두 개 이상을 칼럼을 포함하는 인덱스를 다중 칼럼 인덱스라고 한다.

- 다중 칼럼 인덱스에서 중요한 점은 **인덱스의 두 번째 칼람은 첫 번째 칼럼에 의존해서 정렬되어 있다.**
  - 즉, 두 번째 칼럼의 정렬의 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다.
  - 참고로 컬럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에, 네 번째 칼럼은 세 번째 칼럼의 의존해서 정렬된다.

그렇기 때문에 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며 아주 신중히 결정해야 한다.

![image](https://user-images.githubusercontent.com/43977617/140933576-98eb677d-21f7-48dd-8a3a-cb05b28b1129.png)

</br >

## 인덱스 스캔 방향

인덱스 키값은 항상 오름차순으로 정렬되지만 이 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로도 사용될 수 있다.

~~~sql
SELECT *
FROM employee ORDER BY first_name DESC LIMIT 1;
~~~

MySQL에서 위 쿼리를 실행하기 위해 인덱스를 처음부터 오름차순으로 끝까지 읽어 `first_name`이 가장 큰 값(오름차순으로 읽었을 때 가장 마지막 레코드) 하나를 가져올까?

결론은 아니다. 위 쿼리는 최댓값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 이미 알고 있다. 그렇기 때문에 인덱스를 역순으로 접근해 첫 번째 레코드만 읽는다.

이렇듯 쿼리의 ORDER BY, MIN(), MAX() 함수 등의 최적화가 필요한 경우, **MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만든다.**

