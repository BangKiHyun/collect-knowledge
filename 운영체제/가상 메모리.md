## 가상 메모리

#### 가상 메모리

- 메인 메모리의 크기가 한정되어 있어 물리적인 메모리 크기보다 크기가 큰 프로세서를 실행시킬 수 없다. **메인 메모리보다 크기가 큰 프로세스를 실행시키기 위해 나온 방법**이 가상 메모리이다.
- 프로세서의 모든 코드는 항상 필요한 것이 아니다. 오류 처리하는 부분이나 필요 없는 배열 부분은 실제로 프로세스가 잘 동작한다면 필요 없는 부분이 된다. 따라서 프로세스는 필요한 부분만 메모리에 올림으로써 메인 메모리에 올라가는 프로세스의 크기를 줄인다. 동적 적재와 비슷한 개념이라고 알 수 있다.



#### 장점

- 프로그램은 물리 메모리 크기에 의해 제약을 받지 않는다
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. - CPU 이용률과 처리률 향상



#### 가상 메모리 구현

요구 페이징(Demand Paging)
요구 세그먼테이션(Demand Segmentation)



#### 페이징 기법

- 세그먼테이션과 가상 메모리를 **고정된 크기**로 나누어 메모리를 관리하는 것
- 커다란 크기의 작업을 **일정한 크기**로 나누어 처리하는 방식으로, 불연속적인 메모리 요청 등에 유연하게 처리할 수 있다
- 이 때, 쪼개진 고정된 크기의 블록을 **페이지(page)**, 이에 대응하는 물리 메모리를 페이지와 같은 크기로 나누는 블록 단위를 **프레임(frame)**이라고 한다.
- 페이징 기법이 적용된 시스템에서 가상 주소는 p(페이지 번호), d(offset) 두가지로 나타낸다.(그 정보는 페이지 테이블(PTE) 에 있다)
- 고정된 크기로 나누어 관리하기 때문에 **외부 단편화**가 없다.
- 아래 예시를 통해  어떻게 가상메모리의 논리주소를 갖고, 실제 메인메모리(물리메모리)의 위치를 알 수 있는지 보자

![img](https://k.kakaocdn.net/dn/VLbF6/btquTSGsIis/yHRXYkjCLqbC2YnxFug5W1/img.png)

위 그림은 페이지테이블과 실제 메인메모리에 적재되어있는 형태를 나타낸 그림이다.
P1 페이지 맵핑 테이블을 보면 1번째 page는 12번째 frame에 있다.
논리주소는 <page, offset> 과 같은 형태로 구성되어있다
프레임이 1KB이고 P1의 논리주소 <1,222>를 물리주소로 맵핑시키려면 1KB*12(frame) + 222(offset) = 12510 과 같은 형태로 맵핑된다.

**물리 주소(v) = 프레임 번호 + d(offset)**



#### 세그먼테이션 기법

- 메모리를 **서로 다른 크기**의 논리적인 블록 단위(세그먼트)로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다.
- 미리 분할하는 것이 아니고 메모리를 사용할 시점에 할당된다.
- 각 영역들의 기능, 권한, 필요한 공간의 크기가 모두 다르기 때문에 세그먼테이션 기법으로 분할하여 효율적인 메모리 관리가 가능하도록 한 것이다.
- 서로 다른 크기로 분할하여 메모리를 할당하기 때문에 **내부 단편화**가 없다.
- 세그먼테이션 기법의 **세그먼트 가상주소는 v = <s, d>로 표현**되며 s는 세그먼트 번호를, d는 블록 내 세그먼트 변위를 나타낸다.
- 세그먼테이션을 위한 테이블은 **세그먼트 테이블**이라고 한다. 세그먼트 테이블은 세그먼트 번호와 **시작 주소(base), 세그먼트 크기(limit)**를 갖는다.
- 아래 예시를 통해 확인해보자

![img](https://user-images.githubusercontent.com/34755287/57119448-47043400-6da5-11e9-95da-91cb808de992.png)

위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습니다.

- 논리주소 <2, 100> 를 보면 2번째 세그먼트 번호 <4300, 400> 이라는 세그먼트 테이블을 가르킨다. 그러므로 **4400(v) = 4300(s) + 100(d)** 
- 논리주소 <1, 500>를 보면 1번째 세그먼트 번호 <6300, 400> 이라는 세그먼트 테이블을 가르킨다. limit범위를 벗어나므로 인터럽트를 발생시켜 프로세스를 강제 종료시킨다.